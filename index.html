<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kyrson Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js"></script>
<script>

function fmt(n, frac=6, minFrac=0) {
  if (n === null || n === undefined) return "-";
  const num = Number(n);
  if (!Number.isFinite(num)) return "-";
  if (Math.abs(num) > 1e12) return "-";
  return num.toLocaleString("pl-PL", {
    minimumFractionDigits: minFrac,
    maximumFractionDigits: frac
  });
}

function safeDiv(a, b) {
  const x = Number(a), y = Number(b);
  if (!Number.isFinite(x) || !Number.isFinite(y) || y === 0) return NaN;
  return x / y;
}

function updateConversionPreview() {
  const preview = document.getElementById("conversionPreview");
  const costEstimate = document.getElementById("costEstimate");
  const plnEstimate = document.getElementById("plnEstimate");
  const amount = parseFloat(document.getElementById("amountToBuy").value);
  const currency = document.getElementById("currencySelect").value;


  // na samym poczƒÖtku updateConversionPreview(), po pobraniu amount/currency:
  if (currency === "ETH" && !(typeof window.krsEthPrice === "number" && isFinite(window.krsEthPrice) && window.krsEthPrice > 0)) {
    document.getElementById("conversionPreview").textContent = "‚è≥ ≈Åadowanie kursu...";
    document.getElementById("plnEstimate").textContent = "";
    document.getElementById("costEstimate").textContent = "";
    return;
  }
  if (currency === "USDC" && !(typeof window.krsUsdPrice === "number" && isFinite(window.krsUsdPrice) && window.krsUsdPrice > 0)) {
    document.getElementById("conversionPreview").textContent = "‚è≥ ≈Åadowanie kursu...";
    document.getElementById("plnEstimate").textContent = "";
    document.getElementById("costEstimate").textContent = "";
    return;
  }


  // kursy z window ustawiane w fetchKursy()
  const ethToPln = (Number.isFinite(window.ethPln) && window.ethPln > 0) ? window.ethPln : NaN;
  const usdToPln = (Number.isFinite(window.usdPln) && window.usdPln > 0) ? window.usdPln : NaN;

  const priceEthPerKRS = (typeof window.krsEthPrice === "number" && isFinite(window.krsEthPrice) && window.krsEthPrice > 0)
    ? window.krsEthPrice
    : 0.0001; // fallback

  const priceUsdPerKRS = (typeof window.krsUsdPrice === "number" && isFinite(window.krsUsdPrice) && window.krsUsdPrice > 0)
    ? window.krsUsdPrice
    : NaN;

  if (!isNaN(amount) && amount > 0) {
    if (currency === "ETH") {
      const ethNeeded = amount * priceEthPerKRS;
      const costPLN = Number.isFinite(ethToPln) ? (ethNeeded * ethToPln) : NaN;

      preview.textContent = `Przybli≈ºona cena: ${ethNeeded.toFixed(6)} ETH za ${amount} KRS (1 KRS = ${priceEthPerKRS.toFixed(6)} ETH)`;

      const haveEthPln = Number.isFinite(ethToPln) && ethToPln > 1000;
      plnEstimate.textContent = (haveEthPln && isFinite(costPLN))
        ? `Szacowany koszt: ${costPLN.toFixed(2)} PLN`
        : `Szacowany koszt: -`;

      const gasBuffer = 0.005;
      if (userEthBalance === 0) {
        costEstimate.textContent = "‚ö†Ô∏è Niepo≈ÇƒÖczony portfel lub brak salda ETH";
      } else if (userEthBalance < ethNeeded + gasBuffer) {
        costEstimate.textContent =
          `‚ö†Ô∏è Za ma≈Ço ETH. Potrzeba ~${(ethNeeded + gasBuffer).toFixed(6)} ETH (kupno + gas), masz ${userEthBalance.toFixed(6)} ETH`;
      } else {
        costEstimate.textContent = "";
      }
    } else if (currency === "USDC") {
      const usdcNeeded = amount * priceUsdPerKRS; // ile USDC trzeba w≈Ço≈ºyƒá
      const costPLN = Number.isFinite(usdToPln) ? (usdcNeeded * usdToPln) : NaN;

      preview.textContent =
        `Przybli≈ºona cena: ${fmt(usdcNeeded, 6, 2)} USDC za ${amount} KRS ` +
        `(1 KRS = ${fmt(priceUsdPerKRS, 6, 2)} USDC)`;

      plnEstimate.textContent = isFinite(costPLN)
        ? `Szacowany koszt: ${fmt(costPLN, 2, 2)} PLN`
        : `Szacowany koszt: -`;

      // ostrze≈ºenia o saldzie (USDC na zakup + ETH na gas)
      const gasBufferEth = 0.002;
      if (userUsdcBalance === 0) {
        costEstimate.textContent = "‚ö†Ô∏è Brak salda USDC lub niepo≈ÇƒÖczony portfel";
      } else if (userUsdcBalance < usdcNeeded) {
        costEstimate.textContent = `‚ö†Ô∏è Za ma≈Ço USDC. Potrzeba ~${fmt(usdcNeeded, 6, 2)} USDC, masz ${fmt(userUsdcBalance, 6, 2)} USDC`;
      } else if (userEthBalance < gasBufferEth) {
        costEstimate.textContent = `‚ö†Ô∏è Za ma≈Ço ETH na op≈Çaty (~${gasBufferEth} ETH)`;
      } else {
        costEstimate.textContent = "";
      }
    }
  } else {
    preview.textContent = "";
    plnEstimate.textContent = "";
    costEstimate.textContent = "";
  }
}
</script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #0e0e0e;
      color: #eee;
      margin: 0;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      font-size: 2.2rem;
      font-weight: bold;
      margin-bottom: 2rem;
      color: #aaa;
    }
    .box {
      width: 320px;
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 1.5rem;
      margin-bottom: 1.2rem;
      text-align: center;
      font-size: 1.2rem;
      overflow-wrap: break-word;
    }
    .button-wrapper {
      margin-top: 1.5rem;
    }
    button {
      padding: 0.8rem 1.2rem;
      background-color: #006aff;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
    }
    button:hover {
      background-color: #0052cc;
    }
    #wallet-address {
      font-size: 1rem;
      color: #0f0;
    }
    #wallet-address::before {
      content: "Portfel: ";
      color: #fff;
    }
    input, select {
      padding: 0.5rem;
      margin-top: 1rem;
      width: 280px;
      border-radius: 6px;
      border: 1px solid #666;
      background-color: #222;
      color: #eee;
    }
    .blink {
      animation: blinkAnim 2s infinite;
    }
    @keyframes blinkAnim {
      0%, 100% { color: #000; }
      50% { color: red; }
    }
  </style>
</head>
<body>
  <h1>Kurs Kyrson (KRS)</h1>
  <div class="box">KRS / ETH<br><strong><span id="WETH">-</span></strong></div>
  <div class="box">KRS / USDC<br><strong><span id="USDC">-</span></strong></div>
  <div class="box">ETH w PLN (na podstawie KRS)<br><strong><span id="ETHPLN">-</span></strong></div>
  <div class="box">ETH kurs rynkowy<br><strong><span id="ETHREAL">-</span></strong></div>
  <div class="box" id="alertBox" style="display:none; background-color:#402020; color:#ffaaaa;">‚ö†Ô∏è R√≥≈ºnica kurs√≥w przekracza 5%</div>
  <div class="button-wrapper">
    <button onclick="connectWallet()">üîó Po≈ÇƒÖcz portfel</button>
    <p id="wallet-address">Nie po≈ÇƒÖczono</p>
  </div>
  <div class="box" id="buyBox" style="display:none;">
    Kup Kyrsony<br>
    <input type="number" id="amountToBuy" placeholder="Podaj ilo≈õƒá KRS" oninput="updateConversionPreview()" />
    <select id="currencySelect" onchange="updateConversionPreview()">
      <option value="ETH">ETH</option>
      <!-- DODANE: USDC -->
      <option value="USDC">USDC</option>
    </select>
    <br><br>
    <div id="costEstimate" style="margin-top:1em; font-size:0.9em; color:#f88;"></div>
    <div id="conversionPreview" style="margin-top:1em; font-size:1em; font-weight:bold; color:#0f0; text-shadow: 0 0 5px #0f0;"></div>
    <p id="plnEstimate" style="margin-top:0.5em; font-size:1em; color:#ccc;"></p>
    <button onclick="buyKRS()">üõí Kup teraz</button>
    <p id="buyStatus"></p>
  </div>
  <div class="box" id="poolBox" style="display:none;">
  <strong style="font-size: 1.3rem; color: #0cf;">Pula KRS / USDC</strong><br><br>
  KRS: <strong><span id="krsPoolUSDC">-</span></strong><br>
  USDC: <strong><span id="usdcPool">-</span></strong><br><br>
  <strong style="font-size: 1.3rem; color: #fc0;">Pula KRS / ETH</strong><br><br>
  KRS: <strong><span id="krsPoolWETH">-</span></strong><br>
  ETH (WETH): <strong><span id="ethPool">-</span></strong><br>
  <hr>
  <strong>Warto≈õƒá ca≈Çkowita puli:</strong><br>
  <span><strong><span id="poolValueUSD">-</span></strong> USD</span><br>
  <span><strong><span id="poolValueETH">-</span></strong> ETH</span><br>
  <span><strong><span id="poolValuePLN">-</span></strong> PLN</span>
</div>
  <div class="box" id="balanceBox" style="display:none;">
    Saldo KRS w portfelu:<br>
    <strong><span id="krsBalance">-</span> KRS</strong>
  </div>
  <div class="box">
    <p><strong class="blink">Sieƒá: Arbitrum One</strong></p>
    <p><strong>Kontrakt KRS:</strong><br><code id="krsAddress">0x521e58970fBa0AEAF6DC9C2e994ec9e9CD71A070</code></p>
    <button onclick="copyKRSAddress()">üìã Kopiuj adres</button>
    <br><br>
    <button onclick="addTokenToWallet()">‚ûï Dodaj KRS do portfela</button>
  </div>
  <script>
    const DEBUG = false;

async function fetchKRSPool() {
  document.getElementById("poolBox").style.display = "block";
  try {
    const kursRes = await fetch(`https://raw.githubusercontent.com/chonomitu/krs-monitor/main/kursy.json?t=${Date.now()}`, { cache: "no-cache" });
    const kursData = await kursRes.json();


    const prefer = kursData?.prefer || "viaUSDC";
    const wethVia = Number(kursData?.WETH_viaUSDC) || 0;
    const wethDirect = Number(kursData?.WETH) || 0;

    // to bƒôdzie u≈ºywane do przelicze≈Ñ i podglƒÖdu kupna
    window.krsEthPrice = (prefer === "viaUSDC" && wethVia > 0) ? wethVia : wethDirect;

    // wy≈õwietlanie na g√≥rze
    document.getElementById("WETH").textContent =
      `${fmt(window.krsEthPrice, 8)} ETH` + (prefer === "viaUSDC" ? " (via USDC)" : " (direct)");

    // alert o rozje≈∫dzie (z backendu)
    const diff = Number(kursData?.diff_pct) || 0;
    document.getElementById("alertBox").style.display = diff > 0.05 ? "block" : "none";



    if (!kursData.pool) {
      throw new Error("Brak danych o puli (pool) w kursy.json");
    }

    document.getElementById("krsPoolUSDC").textContent = fmt(kursData.pool.krs_usdc, 2);
    document.getElementById("usdcPool").textContent   = fmt(kursData.pool.usdc, 2);
    document.getElementById("krsPoolWETH").textContent = fmt(kursData.pool.krs_weth, 2);
    document.getElementById("ethPool").textContent     = fmt(kursData.pool.weth, 6);

    document.getElementById("poolValueUSD").textContent = fmt(kursData.pool.value_usd, 2);
    document.getElementById("poolValueETH").textContent = fmt(kursData.pool.value_eth, 6);
    document.getElementById("poolValuePLN").textContent = fmt(kursData.pool.value_pln, 2);
  } catch (err) {
    console.error("Nie uda≈Ço siƒô pobraƒá danych puli:", err);
    document.getElementById("poolBox").innerHTML = "<span style='color:#f55;'>‚ùå Brak danych o puli w kursy.json</span>";
    document.getElementById("poolBox").style.display = "block";
  }
}

// *** STA≈ÅE ***
const KRS_CONTRACT = "0x521e58970fBa0AEAF6DC9C2e994ec9e9CD71A070";

// STARY adres USDC.e (zostawiony, ale nieu≈ºywany):
// const USDC_ADDRESS = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8";

// NOWY: natywny USDC na Arbitrum (6 dec) ‚Äì U≈ªYWANY:
const USDC_ADDRESS = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831";

const KRS_USDC_POOL_ADDRESS = "0xca71156bFe3bBecb281B78BF8bd9C083D1db222b";

const UNISWAP_V3_POOL_ABI = [
  "function slot0() view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)",
  "function token0() view returns (address)",
  "function token1() view returns (address)"
];

const ABI = [
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function approve(address spender, uint256 amount) returns (bool)"
];

let provider, signer;
let userEthBalance = 0;
let userUsdcBalance = 0;

async function connectWallet() {
  try {
    if (!window.ethereum) throw new Error("MetaMask nie jest zainstalowany.");
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    const address = await signer.getAddress();
    document.getElementById("wallet-address").textContent = address;
    document.querySelector(".button-wrapper button").textContent = "‚ùå Od≈ÇƒÖcz portfel";
    document.querySelector(".button-wrapper button").onclick = disconnectWallet;
    document.getElementById("buyBox").style.display = "block";

    fetchBalances();
    fetchKRSBalance(address);
  } catch (err) {
    alert("Nie uda≈Ço siƒô po≈ÇƒÖczyƒá z portfelem: " + err.message);
    console.error(err);
  }
}

function disconnectWallet() {
  provider = null;
  signer = null;
  document.getElementById("wallet-address").textContent = "Nie po≈ÇƒÖczono";
  document.querySelector(".button-wrapper button").textContent = "üîó Po≈ÇƒÖcz portfel";
  document.querySelector(".button-wrapper button").onclick = connectWallet;
  document.getElementById("buyBox").style.display = "none";
  document.getElementById("balanceBox").style.display = "none";
}

async function fetchBalances() {
  if (!signer) return;
  try {
    const address = await signer.getAddress();
    const ethBalanceRaw = await provider.getBalance(address);
    userEthBalance = parseFloat(ethers.utils.formatEther(ethBalanceRaw));

    // UWAGA: teraz odpyta NATYWNY USDC (0xaf88‚Ä¶)
    const usdcContract = new ethers.Contract(USDC_ADDRESS, ["function balanceOf(address) view returns (uint256)"], provider);
    const usdcBalanceRaw = await usdcContract.balanceOf(address);
    userUsdcBalance = parseFloat(ethers.utils.formatUnits(usdcBalanceRaw, 6));

    updateConversionPreview();
  } catch (e) {
    console.error("B≈ÇƒÖd pobierania sald:", e);
  }
}

async function fetchKRSBalance(address) {
  try {
    const contract = new ethers.Contract(KRS_CONTRACT, ABI, provider);
    const rawBalance = await contract.balanceOf(address);
    const decimals = await contract.decimals();
    const balance = ethers.utils.formatUnits(rawBalance, decimals);
    document.getElementById("balanceBox").style.display = "block";
    document.getElementById("krsBalance").textContent = parseFloat(balance).toFixed(2);
  } catch (err) {
    console.error("Nie uda≈Ço siƒô pobraƒá salda KRS:", err);
  }
}

async function getCurrentKrsUsdcPrice() {
  const poolContract = new ethers.Contract(KRS_USDC_POOL_ADDRESS, UNISWAP_V3_POOL_ABI, provider);
  const token0 = await poolContract.token0();
  const token1 = await poolContract.token1();
  const slot0 = await poolContract.slot0();
  const sqrtPriceX96 = slot0.sqrtPriceX96;

  const decimals0 = (token0.toLowerCase() === USDC_ADDRESS.toLowerCase()) ? 6 : 18;
  const decimals1 = (token1.toLowerCase() === KRS_CONTRACT.toLowerCase()) ? 18 : 6;

  const priceRaw = (sqrtPriceX96 / 2 ** 96) ** 2;
  const price = priceRaw * 10 ** (decimals0 - decimals1);

  return price;
}

async function buyKRS() {
  try {
    const userAddress = await signer.getAddress();
    const deadline = Math.floor(Date.now() / 1000) + 1800;
    const gasPrice = await provider.getGasPrice();
    const gasCost = ethers.utils.formatUnits(gasPrice.mul(210000), "gwei");
    const amountStr = document.getElementById("amountToBuy").value;
    const amount = parseFloat(amountStr);
    const currency = document.getElementById("currencySelect").value;

    console.log("Kupno KRS: amount =", amount, ", currency =", currency);

    if (!isNaN(amount) && amount > 0) {
      const router = new ethers.Contract(
        "0xE592427A0AEce92De3Edee1F18E0157C05861564",
        [
          "function exactInputSingle(tuple(address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256)"
        ],
        signer
      );

      if (currency === "ETH") {
        const priceEthPerKRS =
          (typeof window.krsEthPrice === "number" && isFinite(window.krsEthPrice) && window.krsEthPrice > 0)
            ? window.krsEthPrice
            : 0.0001; // awaryjnie

        const ethAmount = ethers.utils.parseEther((amount * priceEthPerKRS).toFixed(6));

        const WETH = new ethers.Contract("0x82af49447d8a07e3bd95bd0d56f35241523fbab1", [
          "function deposit() payable",
          "function approve(address,uint256) returns (bool)"
        ], signer);

        console.log("ETH buy: Wrapping ETH...");
        const wrapTx = await WETH.deposit({ value: ethAmount });
        await wrapTx.wait();
        console.log("ETH buy: Wrapped ETH, approving router...");
        await WETH.approve(router.address, ethAmount);

        const params = {
          tokenIn: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
          tokenOut: KRS_CONTRACT,
          fee: 3000,
          recipient: userAddress,
          deadline: deadline,
          amountIn: ethAmount,
          amountOutMinimum: 0, // TODO: dodaƒá minim√≥wkƒô po quoterze
          sqrtPriceLimitX96: ethers.constants.Zero
        };

        console.log("ETH buy: Calling exactInputSingle with params:", params);
        const tx = await router.exactInputSingle(params);
        document.getElementById("buyStatus").textContent = "‚è≥ Trwa przetwarzanie...";
        await tx.wait();
        console.log("ETH buy: Swap completed.");
      } else if (currency === "USDC") {
        // DODANE: zakup KRS za USDC (natywny 0xaf88‚Ä¶)
        const priceUsdPerKRS =
          (typeof window.krsUsdPrice === "number" && isFinite(window.krsUsdPrice) && window.krsUsdPrice > 0)
            ? window.krsUsdPrice : NaN;
        if (!isFinite(priceUsdPerKRS)) throw new Error("Brak aktualnej ceny KRS w USDC");

        const usdcNeededFloat = amount * priceUsdPerKRS;
        const usdcAmount = ethers.utils.parseUnits(usdcNeededFloat.toFixed(6), 6); // USDC 6 dec

        const USDC = new ethers.Contract(USDC_ADDRESS, [
          "function approve(address,uint256) returns (bool)",
          "function allowance(address,address) view returns (uint256)"
        ], signer);

        const allowance = await USDC.allowance(userAddress, router.address);
        if (allowance.lt(usdcAmount)) {
          const approveTx = await USDC.approve(router.address, usdcAmount);
          document.getElementById("buyStatus").textContent = "‚è≥ Zgoda na wydanie USDC...";
          await approveTx.wait();
        }

        const params = {
          tokenIn: USDC_ADDRESS,
          tokenOut: KRS_CONTRACT,
          fee: 3000,
          recipient: userAddress,
          deadline: deadline,
          amountIn: usdcAmount,
          amountOutMinimum: 0, // TODO: dodaƒá slippage + minOut po quoterze
          sqrtPriceLimitX96: ethers.constants.Zero
        };

        console.log("USDC buy: Calling exactInputSingle with params:", params);
        const tx = await router.exactInputSingle(params);
        document.getElementById("buyStatus").textContent = "‚è≥ Trwa przetwarzanie...";
        await tx.wait();
        console.log("USDC buy: Swap completed.");
      }

      document.getElementById("buyStatus").textContent = "‚úÖ Zakup zako≈Ñczony przez Uniswap!";
      await fetchBalances();
      const ua = await signer.getAddress();
      fetchKRSBalance(ua);
      fetchKRSPool();
    }
  } catch (err) {
    console.error("B≈ÇƒÖd zakupu:", err);
    document.getElementById("buyStatus").textContent = "‚ùå B≈ÇƒÖd zakupu: " + (err.message || err);
  }
}

async function fetchKursy() {
  try {
    // dane z Twojego JSON-a ‚Äì dodane bust cache
    const kursRes = await fetch("https://raw.githubusercontent.com/chonomitu/krs-monitor/main/kursy.json?t=" + Date.now(), { cache: "no-store" }
  );

    const kursData = await kursRes.json();

    // zapisz ceny do window
    window.krsEthPrice = NaN; // policzymy zaraz przez USDC/ETH

    window.krsUsdPrice = Number(kursData.USDC); // USD za 1 KRS

    console.log("kursData.WETH =", kursData.WETH);

    // wy≈õwietlenie KRS/ETH i KRS/USDC
    document.getElementById("WETH").textContent = `${fmt(kursData.WETH, 8)} ETH`;
    document.getElementById("USDC").textContent = `${fmt(kursData.USDC, 6)} USD`;

    // ETH w PLN i USD (do USD/PLN)
    const ethRes = await fetch(
      "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=pln,usd",
      { cache: "no-store" }
    );
    const ethData = await ethRes.json();

    const ethPln = Number(ethData?.ethereum?.pln);
    const ethUsd = Number(ethData?.ethereum?.usd);

    window.ethPln = (Number.isFinite(ethPln) && ethPln > 0) ? ethPln : NaN;
    window.usdPln = (Number.isFinite(ethPln) && Number.isFinite(ethUsd) && ethUsd > 0)
      ? (ethPln / ethUsd)
      : 4.0;

    // **Tu od razu policz w≈Ça≈õciwy ETH/KRS z USDC/KRS**
    if (Number.isFinite(ethUsd) && ethUsd > 0 && Number(kursData.USDC) > 0) {
      window.krsEthPrice = Number(kursData.USDC) / ethUsd; // ETH za 1 KRS
    }


  
    // od≈õwie≈º podglƒÖd kosztu po pobraniu kurs√≥w
    if (typeof updateConversionPreview === "function") updateConversionPreview();

    document.getElementById("ETHREAL").textContent = Number.isFinite(window.ethPln) ? `${fmt(window.ethPln, 2)} PLN` : "-";

    // ETH/PLN z par KRS (heurystyka)
    const usdPln = window.usdPln ?? 4.0;
    const ethPlnFromKrs = (Number(kursData.WETH) > 0)
      ? safeDiv(Number(kursData.USDC) * usdPln, Number(kursData.WETH))
      : NaN;

    document.getElementById("ETHPLN").textContent = Number.isFinite(ethPlnFromKrs) ? `${fmt(ethPlnFromKrs, 2)} PLN` : "-";

    const diff = (Number.isFinite(ethPlnFromKrs) && Number.isFinite(ethPln) && ethPln > 0)
      ? Math.abs(ethPlnFromKrs - ethPln) / ethPln
      : 0;
    document.getElementById("alertBox").style.display = diff > 0.05 ? "block" : "none";

  } catch (e) {
    console.error("B≈ÇƒÖd pobierania danych:", e);
    document.getElementById("ETHREAL").textContent = "B≈ÇƒÖd";
    document.getElementById("ETHPLN").textContent = "B≈ÇƒÖd";
  }
}

window.addEventListener("DOMContentLoaded", () => {
  fetchKursy();
  fetchKRSPool();
});
  </script>

  <script>
  function copyKRSAddress() {
    const el = document.getElementById("krsAddress");
    if (!el) {
      alert("‚ùå Nie znaleziono adresu KRS.");
      return;
    }
    const text = el.textContent;

    navigator.clipboard.writeText(text).then(() => {
      alert("‚úÖ Skopiowano adres KRS do schowka:\n" + text);
    }).catch(err => {
      console.error("‚õî B≈ÇƒÖd kopiowania:", err);
      alert("‚ùå Nie uda≈Ço siƒô skopiowaƒá adresu.");
    });
  }
  </script>

  <script>
  function addTokenToWallet() {
    if (!window.ethereum || !window.ethereum.request) {
      alert("‚ùå MetaMask nie jest dostƒôpny.");
      return;
    }

    ethereum.request({
      method: 'wallet_watchAsset',
      params: {
        type: 'ERC20',
        options: {
          address: '0x521e58970fBa0AEAF6DC9C2e994ec9e9CD71A070', // KRS token
          symbol: 'KRS',
          decimals: 18,
          image: 'https://kyrson.pl/static/img/krs-icon.png'
        }
      }
    })
    .then((success) => {
      if (success) {
        alert("‚úÖ Token KRS zosta≈Ç dodany do MetaMask!");
      } else {
        alert("‚ùå U≈ºytkownik anulowa≈Ç dodanie tokena.");
      }
    })
    .catch((error) => {
      console.error("‚õî B≈ÇƒÖd dodawania tokena:", error);
      alert("‚ö†Ô∏è Nie uda≈Ço siƒô dodaƒá tokena. Sprawd≈∫ konsolƒô.");
    });
  }
  </script>

</body>
</html>
